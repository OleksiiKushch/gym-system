package org.example.facade.impl;

import org.apache.commons.lang3.StringUtils;
import org.example.dto.TrainerDto;
import org.example.dto.form.search.SearchTrainerTrainingsPayload;
import org.example.dto.response.SimpleTrainerResponse;
import org.example.dto.response.TrainerProfileResponse;
import org.example.dto.response.TrainerTrainingResponse;
import org.example.entity.Trainee;
import org.example.entity.Trainer;
import org.example.entity.Training;
import org.example.entity.TrainingType;
import org.example.entity.search.TrainerTrainingsCriteria;
import org.example.exception.NotFoundException;
import org.example.service.TraineeService;
import org.example.service.TrainerService;
import org.example.service.TrainingService;
import org.example.service.UserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.modelmapper.ModelMapper;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class DefaultTrainerFacadeUnitTest {

    private static final String TEST_USERNAME = "John.Doe";
    private static final String TEST_PASSWORD = "password";
    private static final String ENCODED_PASSWORD = "encodedPassword";
    private static final String GENERATED_PASSWORD = "generated_password";
    private static final String NEW_FIRST_NAME = "NewJohn";
    private static final String NEW_LAST_NAME = "NewDoe";

    private static final String TRAINER_NOT_FOUND_EXPECTED_EXCEPTION_MSG = "Trainer with username '" + TEST_USERNAME + "' not found";
    private static final String TRAINEE_NOT_FOUND_EXPECTED_EXCEPTION_MSG = "Trainee with username '" + TEST_USERNAME + "' not found";

    @InjectMocks
    DefaultTrainerFacade testInstance;

    @Mock
    UserService userService;
    @Mock
    TrainerService trainerService;
    @Mock
    TraineeService traineeService;
    @Mock
    ModelMapper modelMapper;
    @Mock
    TrainingService trainingService;
    @Mock
    PasswordEncoder passwordEncoder;

    @Mock
    TrainerDto trainerDto;
    @Mock
    Trainer trainer;
    @Mock
    Trainer newTrainer;
    @Mock
    Trainee trainee;
    @Mock
    TrainerProfileResponse trainerProfileResponse;

    @Mock
    Trainer trainer1;
    @Mock
    SimpleTrainerResponse simpleTrainerResponse1;
    @Mock
    Trainer trainer2;
    @Mock
    SimpleTrainerResponse simpleTrainerResponse2;
    @Mock
    SearchTrainerTrainingsPayload payload;
    @Mock
    TrainerTrainingsCriteria trainerTrainingsCriteria;
    @Mock
    TrainingType newTrainingType;

    @Mock
    Training training1;
    @Mock
    TrainerTrainingResponse trainerTrainingResponse1;
    @Mock
    Training training2;
    @Mock
    TrainerTrainingResponse trainerTrainingResponse2;

    List<Trainer> trainers;
    List<Training> trainings;

    @BeforeEach
    void setUp() {
        testInstance.setUserService(userService);
        testInstance.setPasswordEncoder(passwordEncoder);
        trainers = List.of(trainer1, trainer2);
        trainings = List.of(training1, training2);
    }

    @Test
    void shouldRegisterTrainer() {
        setUpTrainerDtoForRegistration();
        when(trainer.getPassword()).thenReturn(TEST_PASSWORD);
        when(passwordEncoder.encode(TEST_PASSWORD)).thenReturn(ENCODED_PASSWORD);

        testInstance.registerTrainer(trainerDto);

        verifyRegistrationTrainer();
        verify(trainer).setActive(true);
        verify(userService, never()).generateRandomPassword();
        verify(trainer).setPassword(ENCODED_PASSWORD);
    }

    @Test
    void shouldRegisterTrainer_whenPasswordAutoGeneratedBecauseItsNull() {
        setUpTrainerDtoForRegistration();
        when(trainer.getPassword()).thenReturn(null);
        when(userService.generateRandomPassword()).thenReturn(GENERATED_PASSWORD);
        when(passwordEncoder.encode(GENERATED_PASSWORD)).thenReturn(ENCODED_PASSWORD);

        testInstance.registerTrainer(trainerDto);

        verifyRegistrationTrainer();
        verify(trainer).setActive(true);
        verify(userService).generateRandomPassword();
        verify(trainer).setPassword(ENCODED_PASSWORD);
    }

    @Test
    void shouldRegisterTrainer_whenPasswordAutoGeneratedBecauseItsEmpty() {
        setUpTrainerDtoForRegistration();
        when(trainer.getPassword()).thenReturn(StringUtils.EMPTY);
        when(userService.generateRandomPassword()).thenReturn(GENERATED_PASSWORD);
        when(passwordEncoder.encode(GENERATED_PASSWORD)).thenReturn(ENCODED_PASSWORD);

        testInstance.registerTrainer(trainerDto);

        verifyRegistrationTrainer();
        verify(trainer).setActive(true);
        verify(userService).generateRandomPassword();
        verify(trainer).setPassword(ENCODED_PASSWORD);
    }

    @Test
    void shouldGetTrainerProfile() {
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.of(trainer));
        when(modelMapper.map(trainer, TrainerProfileResponse.class)).thenReturn(trainerProfileResponse);

        TrainerProfileResponse actualResult = testInstance.getTrainerProfile(TEST_USERNAME);

        assertEquals(trainerProfileResponse, actualResult);
    }

    @Test
    void getTrainerProfile_shouldThrowException_whenTraineeNotFound() {
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.empty());

        Exception exception = assertThrows(NotFoundException.class, () ->
                testInstance.getTrainerProfile(TEST_USERNAME));

        assertEquals(TRAINER_NOT_FOUND_EXPECTED_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldGetTrainersThatNotAssignedOnTrainee() {
        when(traineeService.getTraineeForUsername(TEST_USERNAME)).thenReturn(Optional.of(trainee));
        when(trainerService.getAllTrainersThatNotAssignedOnTrainee(TEST_USERNAME)).thenReturn(trainers);
        when(modelMapper.map(trainer1, SimpleTrainerResponse.class)).thenReturn(simpleTrainerResponse1);
        when(modelMapper.map(trainer2, SimpleTrainerResponse.class)).thenReturn(simpleTrainerResponse2);

        List<SimpleTrainerResponse> actualResult = testInstance.getTrainersThatNotAssignedOnTrainee(TEST_USERNAME);

        assertEquals(trainers.size(), actualResult.size());
        assertTrue(actualResult.contains(simpleTrainerResponse1));
        assertTrue(actualResult.contains(simpleTrainerResponse2));
    }

    @Test
    void getTrainersThatNotAssignedOnTrainee_shouldThrowException_whenTraineeNotFound() {
        when(traineeService.getTraineeForUsername(TEST_USERNAME)).thenReturn(Optional.empty());

        Exception exception = assertThrows(NotFoundException.class, () ->
                testInstance.getTrainersThatNotAssignedOnTrainee(TEST_USERNAME));

        assertEquals(TRAINEE_NOT_FOUND_EXPECTED_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldGetTrainerTrainings() {
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.of(trainer));
        when(modelMapper.map(payload, TrainerTrainingsCriteria.class)).thenReturn(trainerTrainingsCriteria);
        when(trainingService.getTrainerTrainings(trainerTrainingsCriteria)).thenReturn(trainings);
        when(modelMapper.map(training1, TrainerTrainingResponse.class)).thenReturn(trainerTrainingResponse1);
        when(modelMapper.map(training2, TrainerTrainingResponse.class)).thenReturn(trainerTrainingResponse2);

        List<TrainerTrainingResponse> actualResult = testInstance.getTrainerTrainings(TEST_USERNAME, payload);

        verify(trainerTrainingsCriteria).setTrainerUsername(TEST_USERNAME);
        assertEquals(trainings.size(), actualResult.size());
        assertTrue(actualResult.contains(trainerTrainingResponse1));
        assertTrue(actualResult.contains(trainerTrainingResponse2));
    }

    @Test
    void getTrainerTrainings_shouldThrowException_whenTrainerNotFound() {
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.empty());

        Exception exception = assertThrows(NotFoundException.class, () ->
                testInstance.getTrainerTrainings(TEST_USERNAME, payload));

        assertEquals(TRAINER_NOT_FOUND_EXPECTED_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldUpdateTrainer() {
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.of(trainer));
        when(modelMapper.map(trainerDto, Trainer.class)).thenReturn(newTrainer);
        prepareNewTrainer();
        when(trainer.getUsername()).thenReturn(TEST_USERNAME);
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.of(trainer));
        when(modelMapper.map(trainer, TrainerProfileResponse.class)).thenReturn(trainerProfileResponse);

        TrainerProfileResponse actualResult = testInstance.updateTrainer(TEST_USERNAME, trainerDto);

        verifyUpdatedTrainerFields();
        verify(trainerService).updateTrainer(trainer);
        assertEquals(trainerProfileResponse, actualResult);
    }

    @Test
    void updateTrainer_shouldThrowException_whenTrainerNotFound() {
        when(trainerService.getTrainerForUsername(TEST_USERNAME)).thenReturn(Optional.empty());

        Exception exception = assertThrows(NotFoundException.class, () ->
                testInstance.updateTrainer(TEST_USERNAME, trainerDto));

        assertEquals(TRAINER_NOT_FOUND_EXPECTED_EXCEPTION_MSG, exception.getMessage());
    }

    void setUpTrainerDtoForRegistration() {
        when(modelMapper.map(trainerDto, Trainer.class)).thenReturn(trainer);
        when(userService.calculateUsername(trainer)).thenReturn(TEST_USERNAME);
    }

    void verifyRegistrationTrainer() {
        verify(trainer).setUsername(TEST_USERNAME);
        verify(trainerService).createTrainer(trainer);
    }

    void prepareNewTrainer() {
        when(newTrainer.getFirstName()).thenReturn(NEW_FIRST_NAME);
        when(newTrainer.getLastName()).thenReturn(NEW_LAST_NAME);
        when(newTrainer.getSpecialization()).thenReturn(newTrainingType);
        when(newTrainer.getIsActive()).thenReturn(true);
    }

    void verifyUpdatedTrainerFields() {
        verify(trainer).setFirstName(NEW_FIRST_NAME);
        verify(trainer).setLastName(NEW_LAST_NAME);
        verify(trainer).setSpecialization(newTrainingType);
        verify(trainer).setIsActive(true);
    }
}
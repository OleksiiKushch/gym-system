package org.example.dao.impl.inmemory;

import org.example.config.storage.inmemory.InMemoryStorageWithIntId;
import org.example.entity.Trainer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class InMemoryTrainerDaoUnitTest {

    private static final int ID = 1;
    private static final int AUTO_GENERATED_ID = 2;
    private static final String TRAINER_ALREADY_EXISTS_EXCEPTION_MSG = "User (Trainer) with id '" + ID + "' already exists";
    private static final String TRAINER_DOES_NOT_EXISTS_EXCEPTION_MSG = "User (Trainer) with id '" + ID + "' does not exist";

    @InjectMocks
    InMemoryTrainerDao testInstance;

    @Mock
    InMemoryStorageWithIntId<Trainer> trainerStorage;

    @Spy
    Trainer trainer;

    @Test
    void shouldInsert_whenTrainerWithFollowingIdDoseNotExists() {
        when(trainer.getUserId()).thenReturn(ID);
        when(trainerStorage.containsKey(ID)).thenReturn(false);

        testInstance.insert(trainer);

        verify(trainerStorage).put(ID, trainer);
    }

    @Test
    void shouldThrowException_whenInsertAndTrainerWithFollowingIdAlreadyExists() {
        when(trainer.getUserId()).thenReturn(ID);
        when(trainerStorage.containsKey(ID)).thenReturn(true);

        Exception exception = assertThrows(IllegalArgumentException.class, () ->
            testInstance.insert(trainer)
        );

        assertEquals(TRAINER_ALREADY_EXISTS_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldInsertWithAutoGeneratedId_whenIdIsNotPresent() {
        when(trainerStorage.findNextId()).thenReturn(AUTO_GENERATED_ID);

        testInstance.insert(trainer);

        verify(trainer).setUserId(AUTO_GENERATED_ID);
        verify(trainerStorage).put(AUTO_GENERATED_ID, trainer);
    }

    @Test
    void shouldUpdate_whenThereIsTrainerWithFollowingId() {
        when(trainer.getUserId()).thenReturn(ID);
        when(trainerStorage.containsKey(ID)).thenReturn(true);

        testInstance.update(trainer);

        verify(trainerStorage).put(ID, trainer);
    }

    @Test
    void shouldThrowException_whenThereIsNotTrainerWithFollowingId() {
        when(trainer.getUserId()).thenReturn(ID);
        when(trainerStorage.containsKey(ID)).thenReturn(false);

        Exception exception = assertThrows(IllegalArgumentException.class, () ->
            testInstance.update(trainer)
        );

        assertEquals(TRAINER_DOES_NOT_EXISTS_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldFindTrainerById() {
        when(trainerStorage.get(ID)).thenReturn(trainer);

        Optional<Trainer> actualResult = testInstance.findById(ID);

        assertTrue(actualResult.isPresent());
        assertEquals(trainer, actualResult.get());
    }

    @Test
    void shouldFindAllTrainers() {
        testInstance.findAll();

        verify(trainerStorage).values();
    }
}
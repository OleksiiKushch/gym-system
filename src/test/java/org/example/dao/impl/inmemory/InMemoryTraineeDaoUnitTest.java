package org.example.dao.impl.inmemory;

import org.example.config.storage.inmemory.InMemoryStorageWithIntId;
import org.example.entity.Trainee;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class InMemoryTraineeDaoUnitTest {

    private static final int ID = 1;
    private static final int AUTO_GENERATED_ID = 2;
    private static final String TRAINEE_ALREADY_EXISTS_EXCEPTION_MSG = "User (Trainee) with id '" + ID + "' already exists";
    private static final String TRAINEE_DOES_NOT_EXISTS_EXCEPTION_MSG = "User (Trainee) with id '" + ID + "' does not exist";

    @InjectMocks
    InMemoryTraineeDao testInstance;

    @Mock
    InMemoryStorageWithIntId<Trainee> traineeStorage;

    @Spy
    Trainee trainee;

    @Test
    void shouldInsert_whenTraineeWithFollowingIdDoseNotExists() {
        when(trainee.getUserId()).thenReturn(ID);
        when(traineeStorage.containsKey(ID)).thenReturn(false);

        testInstance.insert(trainee);

        verify(traineeStorage).put(ID, trainee);
    }

    @Test
    void shouldThrowException_whenInsertAndTraineeWithFollowingIdAlreadyExists() {
        when(trainee.getUserId()).thenReturn(ID);
        when(traineeStorage.containsKey(ID)).thenReturn(true);

        Exception exception = assertThrows(IllegalArgumentException.class, () ->
            testInstance.insert(trainee)
        );

        assertEquals(TRAINEE_ALREADY_EXISTS_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldInsertWithAutoGeneratedId_whenIdIsNotPresent() {
        when(traineeStorage.findNextId()).thenReturn(AUTO_GENERATED_ID);

        testInstance.insert(trainee);

        verify(trainee).setUserId(AUTO_GENERATED_ID);
        verify(traineeStorage).put(AUTO_GENERATED_ID, trainee);
    }

    @Test
    void shouldUpdate_whenThereIsTraineeWithFollowingId() {
        when(trainee.getUserId()).thenReturn(ID);
        when(traineeStorage.containsKey(ID)).thenReturn(true);

        testInstance.update(trainee);

        verify(traineeStorage).put(ID, trainee);
    }

    @Test
    void shouldThrowException_whenThereIsNotTraineeWithFollowingId() {
        when(trainee.getUserId()).thenReturn(ID);
        when(traineeStorage.containsKey(ID)).thenReturn(false);

        Exception exception = assertThrows(IllegalArgumentException.class, () ->
            testInstance.update(trainee)
        );

        assertEquals(TRAINEE_DOES_NOT_EXISTS_EXCEPTION_MSG, exception.getMessage());
    }

    @Test
    void shouldRemoveTrainee() {
        testInstance.remove(ID);

        verify(traineeStorage).remove(ID);
    }

    @Test
    void shouldFindTraineeById() {
        when(traineeStorage.get(ID)).thenReturn(trainee);

        Optional<Trainee> actualResult = testInstance.findById(ID);

        assertTrue(actualResult.isPresent());
        assertEquals(trainee, actualResult.get());
    }

    @Test
    void shouldFindAllTrainees() {
        testInstance.findAll();

        verify(traineeStorage).values();
    }
}